---
title: "Week 3 - Data Manipulation: `tidyr`"
author: "Emorie D Beck"
format: 
  revealjs:
    incremental: true
    code-tools: true
    code-copy: true
    code-line-numbers: true
    code-link: true
    preview-links: true
    slide-number: true
    self-contained: true
    css: custom.css
    theme: psc290
    highlight-style: atom-one-dark
    margin-left: "0"
    margin-right: "0"
    # width: 1400
    # height: 900
    footer: "PSC 290 - Data Management and Cleaning"
    logo: "https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/01-week1-intro/02-code/02-images/ucdavis_logo_blue.png"
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r, echo = F}
library(knitr)
library(psych)
library(plyr)
library(tidyverse)
```


------------------------------------------------------------------------

::: {.columns .v-center-container}
::: {.column width="70%"}
<p style="font-size:160%;">

Data Wrangling in `tidyr`

</p>
:::

::: {.column width="30%"}
```{r, fig.align='center'}
knitr::include_graphics("https://github.com/rstudio/hex-stickers/raw/master/thumbs/tidyr.png")
```
:::
:::

## `tidyr`

-   Now, let's build off what we learned from dplyr and focus on *reshaping* and *merging* our data.
-   First, the reshapers:

1.  `pivot_longer()`, which takes a "wide" format data frame and makes it long.\
2.  `pivot_wider()`, which takes a "long" format data frame and makes it wide.

## `tidyr`

-   Next, the mergers:

3.  `full_join()`, which merges *all* rows in either data frame\
4.  `inner_join()`, which merges rows whose keys are present in *both* data frames\
5.  `left_join()`, which "prioritizes" the first data set\
6.  `right_join()`, which "prioritizes" the second data set

::: fragment
(See also:`anti_join()` and `semi_join()`)
:::

# Key `tidyr` Functions

## 1. `pivot_longer()` {.smaller}

-   (Formerly `gather()`) Makes wide data long, based on a key <font size="5">
-   Core arguments:
    -   `data`: the data, blank if piped
    -   `cols`: columns to be made long, selected via `select()` calls
    -   `names_to`: name(s) of key column(s) in new long data frame (string or string vector)
    -   `values_to`: name of values in new long data frame (string)
    -   `names_sep`: separator in column headers, if multiple keys
    -   `values_drop_na`: drop missing cells (similar to `na.rm = T`) </font>

## 1. `pivot_longer()`: Basic Application

Let's start with an easy one -- one key, one value:

::: columns
::: column
```{r, echo=TRUE, results = 'hide'}
bfi %>%
  rownames_to_column("SID") %>%
  pivot_longer(
    cols = A1:O5
    , names_to = "item"
    , values_to = "values"
    , values_drop_na = T
  ) %>%
  print(n = 8)
```
:::

::: column
```{r, echo=F}
bfi %>%
  rownames_to_column("SID") %>%
  pivot_longer(
    cols = A1:O5
    , names_to = "item"
    , values_to = "values"
    , values_drop_na = T
  ) %>%
  print(n = 8)
```
:::
:::

## 1. `pivot_longer()`: More Advanced Application

Now a harder one -- two keys, one value:

::: columns
::: column
```{r, echo=TRUE, results = 'hide'}
bfi %>%
  rownames_to_column("SID") %>%
  pivot_longer(
    cols = A1:O5
    , names_to = c("trait", "item_num")
    , names_sep = -1
    , values_to = "values"
    , values_drop_na = T
  ) %>%
  print(n = 8)
```
:::

::: column
```{r, echo=F}
bfi %>%
  rownames_to_column("SID") %>%
  pivot_longer(
    cols = A1:O5
    , names_to = c("trait", "item_num")
    , names_sep = -1
    , values_to = "values"
    , values_drop_na = T
  ) %>%
  print(n = 8)
```
:::
:::

## 2. `pivot_wider()` {.smaller}

-   (Formerly `spread()`) Makes wide data long, based on a key <font size="6">
-   Core arguments:
    -   `data`: the data, blank if piped
    -   `names_from`: name(s) of key column(s) in new long data frame (string or string vector)
    -   `names_sep`: separator in column headers, if multiple keys
    -   `names_glue`: specify multiple or custom separators of multiple keys
    -   `values_from`: name of values in new long data frame (string)
    -   `values_fn`: function applied to data with duplicate labels </font>

## 2. `pivot_wider()`: Basic Application

```{r, results = 'hide'}

bfi_long <- bfi %>%
  rownames_to_column("SID") %>%
  pivot_longer(
    cols = A1:O5
    , names_to = "item"
    , values_to = "values"
    , values_drop_na = T
  )
```

```{r, echo=TRUE}
#| code-line-numbers: "|2|3"
bfi_long %>%
  pivot_wider(
    names_from = "item"
    , values_from = "values"
  )
```

## 2. `pivot_wider()`: More Advanced

```{r, results = 'hide'}
bfi_long <- bfi %>%
  rownames_to_column("SID") %>%
  pivot_longer(
    cols = A1:O5
    , names_to = c("trait", "item_num")
    , names_sep = -1
    , values_to = "values"
    , values_drop_na = T
  )
```

```{r, echo = T}
bfi_long %>%
  pivot_wider(
    names_from = c("trait", "item_num")
    , values_from = "values"
    , names_sep = "_"
  )
```

## 2. `pivot_wider()`: A Little More Advanced

```{r, echo = T}
bfi_long %>%
  select(-item_num) %>%
  pivot_wider(
    names_from = "trait"
    , values_from = "values"
    , names_sep = "_"
    , values_fn = mean
  )
```

# More `dplyr` Functions

## The `_join()` Functions

::: columns
::: {.column width="60%"}
-   Often we may need to pull different data from different sources
-   There are lots of reasons to need to do this
-   We don't have time to get into all the use cases here, so we'll talk about them in high level terms
:::

::: {.column width="40%"}
-   We'll focus on:
    -   `full_join()`
    -   `inner_join()`
    -   `left_join()`
    -   `right_join()`
:::
:::

## The `_join()` Functions

-   Let's separate demographic and BFI data

::: columns
::: column
::: fragment
```{r, echo = T}
#| code-line-numbers: "|3"
bfi_only <- bfi %>% 
  rownames_to_column("SID") %>%
  select(SID, matches("[0-9]"))
bfi_only %>% as_tibble() %>% print(n = 6)
```
:::
:::

::: column
::: fragment
```{r, echo = T}
#| code-line-numbers: "|3"
bfi_dem <- bfi %>%
  rownames_to_column("SID") %>%
  select(SID, education, gender, age)
bfi_dem %>% as_tibble() %>% print(n = 6)
```
:::
:::
:::

## 3. `full_join()`

Most simply, we can put those back together keeping all observations.

::: columns
::: column
::: fragment
```{r, echo = T}
bfi_only %>%
  full_join(bfi_dem) %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::

::: column
::: fragment
```{r, echo = T}
bfi %>%
  rownames_to_column("SID") %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::
:::

## 4. `inner_join()`

We can also keep all rows present in *both* data frames

::: columns
::: column
::: fragment
```{r, echo = T}
#| code-line-numbers: "|1-2|4-5|3"
bfi_dem %>%
  filter(row_number() %in% 1:1700) %>%
  inner_join(
    bfi_only %>%
      filter(row_number() %in% 1200:2800)
  ) %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::

::: column
::: fragment
```{r, echo = T}
bfi %>%
  rownames_to_column("SID") %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::
:::

## 5. `left_join()`

Or all rows present in the left (first) data frame, perhaps if it's a subset of people with complete data

::: columns
::: column
::: fragment
```{r, echo = T}
#| code-line-numbers: "|2|3"
bfi_dem %>%
  drop_na() %>%
  left_join(bfi_only) %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::

::: column
::: fragment
```{r, echo = T}
bfi %>%
  rownames_to_column("SID") %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::
:::

## 6. `right_join()`

Or all rows present in the right (second) data frame, such as I do when I join a codebook with raw data

::: columns
::: column
::: fragment
```{r, echo = T}
#| code-line-numbers: "|3"
bfi_dem %>%
  drop_na() %>%
  right_join(bfi_only) %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::

::: column
::: fragment
```{r, echo = T}
bfi %>%
  rownames_to_column("SID") %>%
  as_tibble() %>%
  print(n = 6)
```
:::
:::
:::
