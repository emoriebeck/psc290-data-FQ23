---
title: "Week 2 - Data Manipulation: `dplyr`"
author: "Emorie D Beck"
format: 
  revealjs:
    incremental: true
    code-tools: true
    code-copy: true
    code-line-numbers: true
    code-link: true
    preview-links: true
    slide-number: true
    self-contained: true
    css: custom.css
    theme: psc290
    highlight-style: atom-one-dark
    margin-left: "0"
    margin-right: "0"
    # width: 1400
    # height: 900
    footer: "PSC 290 - Data Management and Cleaning"
    logo: "https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/01-week1-intro/02-code/02-images/ucdavis_logo_blue.png"
editor: visual
editor_options: 
  chunk_output_type: console
---


```{r, echo = F}
library(knitr)
library(psych)
library(plyr)
library(tidyverse)
```


------------------------------------------------------------------------

::: {.columns .v-center-container}
::: {.column width="70%"}
<p style="font-size:160%;">

Data Manipulation in `dplyr`

</p>
:::

::: {.column width="30%"}
```{r, fig.align='center'}
knitr::include_graphics("https://github.com/rstudio/hex-stickers/raw/master/thumbs/dplyr.png")
```
:::
:::

## Core Functions

1.  **`%>%`**: The pipe. Read as "and then."
2.  **`filter()`**: Pick observations (rows) by their values.
3.  **`select()`**: Pick variables (columns) by their names.
4.  **`arrange()`**: Reorder the rows.
5.  **`group_by()`**: Implicitly split the data set by grouping by names (columns).
6.  **`mutate()`**: Create new variables with functions of existing variables.
7.  **`summarize()` / `summarise()`**: Collapse many values down to a single summary.

## Core Functions

::: columns
::: {.column width="40%"}
::: nonincremental
1.  **`%>%`**
2.  **`filter()`**
3.  **`select()`**
4.  **`arrange()`**
5.  **`group_by()`**
6.  **`mutate()`**
7.  **`summarize()`**
:::
:::

::: {.column width="60%" style="text-align: center; background-color: #FFD966; color: black; border: 5px solid #033266;"}
Although each of these functions are powerful alone, they are incredibly powerful in conjunction with one another. So below, I'll briefly introduce each function, then link them all together using an example of basic data cleaning and summary.
:::
:::

## 1. `%>%`

-   The pipe `%>%` is wonderful. It makes coding intuitive. Often in coding, you need to use so-called nested functions. For example, you might want to round a number after taking the square of 43.

::: fragment
```{r, echo = T}
sqrt(43)
round(sqrt(43), 2)
```
:::

## 1. `%>%`

The issue with this comes whenever we need to do a series of operations on a data set or other type of object. In such cases, if we run it in a single call, then we have to start in the middle and read our way out.

```{r, echo = T}
round(sqrt(43/2), 2)
```

## 1. `%>%`

The pipe solves this by allowing you to read from left to right (or top to bottom). The easiest way to think of it is that each call of `%>%` reads and operates as "and then." So with the rounded square root of 43, for example:

::: fragment
```{r, echo = T}
sqrt(43) %>%
  round(2)
```
:::

## 2. `filter()`

::: fragment
Often times, when conducting research (experiments or otherwise), there are observations (people, specific trials, etc.) that you don't want to include.
:::

<!-- Say for example, that you're interested personality change in adolescence, but you just opened a survey up online. So when you actually download and examine your data, you realize that you have an age range of something like 3-86, not 12-18. In this case, you want to get rid of the people over 18 -- that is, `filter()` them out.   -->

::: fragment
```{r, echo=TRUE}
data(bfi) # grab the bfi data from the psych package
bfi <- bfi %>% as_tibble()
head(bfi)
```
:::

## 2. `filter()`

Often times, when conducting research (experiments or otherwise), there are observations (people, specific trials, etc.) that you don't want to include.

::: fragment
```{r, echo = T}
summary(bfi$age) # get age descriptives
```
:::

## 2. `filter()`

Often times, when conducting research (experiments or otherwise), there are observations (people, specific trials, etc.) that you don't want to include.

::: fragment
```{r, echo = T}
#| code-line-numbers: "|2"
bfi2 <- bfi %>% # see a pipe!
  filter(age <= 18) # filter to age up to 18

summary(bfi2$age) # summary of the new data 
```
:::

::: fragment
But this isn't quite right. We still have folks below 12. But, the beauty of `filter()` is that you can do sequence of `OR` and `AND` statements when there is more than one condition, such as up to 18 `AND` at least 12.
:::

## 2. `filter()`

Often times, when conducting research (experiments or otherwise), there are observations (people, specific trials, etc.) that you don't want to include.

::: fragment
```{r, echo = T}
bfi2 <- bfi %>%
  filter(age <= 18 & age >= 12) # filter to age up to 18 and at least 12

summary(bfi2$age) # summary of the new data 
```
:::

::: fragment
Got it!
:::

## 2. `filter()`

-   But filter works for more use cases than just conditional
    -   `<`, `>`, `<=`, and `>=`
-   It can also be used for cases where we want a single values to match cases with text.
-   To do that, let's convert one of the variables in the `bfi` data frame to a string.
-   So let's change gender (1 = male, 2 = female) to text (we'll get into factors later).

::: fragment
```{r, echo = T}
bfi$education <- plyr::mapvalues(bfi$education, 1:5, c("Below HS", "HS", "Some College", "College", "Higher Degree"))
```
:::

## 2. `filter()`

Now let's try a few things:

<font color = "#033266">**1. Create a data set with only individuals with some college (`==`).**</font>

::: fragment
```{r, echo = T}
bfi2 <- bfi %>% 
  filter(education == "Some College")
unique(bfi2$education)
```
:::

## 2. `filter()`

Now let's try a few things:

<font color = "#033266">**2. Create a data set with only people age 18 (`==`).**</font>

::: fragment
```{r, echo = T}
bfi2 <- bfi %>%
  filter(age == 18)
summary(bfi2$age)
```
:::

## 2. `filter()`

Now let's try a few things:

<font color = "#033266">**3. Create a data set with individuals with some college or above (`%in%`).**</font>

::: fragment
```{r, echo = T}
bfi2 <- bfi %>%
  filter(education %in% c("Some College", "College", "Higher Degree"))
unique(bfi2$education)
```
:::

::: fragment
`%in%` is great. It compares a column to a vector rather than just a single value, you can compare it to several

```{r, echo = T}
bfi2 <- bfi %>%
  filter(age %in% 12:18)
summary(bfi2$age)
```
:::

## 3. `select()`

-   If `filter()` is for pulling certain observations (rows), then `select()` is for pulling certain variables (columns).
-   it's good practice to remove these columns to stop your environment from becoming cluttered and eating up your RAM.

## 3. `select()`

-   In our `bfi` data, most of these have been pre-removed, so instead, we'll imagine we don't want to use any indicators of Agreeableness (A1-A5) and that we aren't interested in gender.
-   With `select()`, there are few ways choose variables. We can bare quote name the ones we want to keep, bare quote names we want to remove, or use any of a number of `select()` helper functions.

## 3. `select()`:

### A. Bare quote columns we want to keep:

::: columns
::: column
::: fragment
```{r, echo = T}
#| code-line-numbers: "|2"
bfi %>%
  select(C1, C2, C3, C4, C5) %>%
  print(n = 6)
```
:::
:::

::: column
::: fragment
```{r, echo=T}
#| code-line-numbers: "|2"
bfi %>%
  select(C1:C5) %>%
  print(n = 6)
```

<!-- We can also use `:` to grab a *range* of columns.   -->
:::
:::
:::

## 3. `select()`:

### B. Bare quote columns we don't want to keep:

::: fragment
```{r, echo = T}
#| code-line-numbers: "|2"
bfi %>% 
  select(-(A1:A5), -gender) %>% # Note the `()` around the columns
  print(n = 6)
```
:::

## 3. `select()`:

### C. Add or remove using `select()` helper functions.

::: columns
::: {.column width="40%"}
-   `starts_with()`\
-   `ends_with()`
-   `contains()`
-   `matches()`
-   `num_range()`
-   `one_of()`
-   `all_of()`
:::

::: {.column width="60%"}
::: fragment
```{r, echo = T}
bfi %>%
  select(starts_with("C"))
```
:::
:::
:::

## 4. `arrange()`

-   Sometimes, either in order to get a better sense of our data or in order to well, order our data, we want to sort it
-   Although there is a base `R` `sort()` function, the `arrange()` function is `tidyverse` version that plays nicely with other `tidyverse functions`.

## 4. `arrange()`

::: columns
So in our previous examples, we could also `arrange()` our data by age or education, rather than simply filtering. (Or as we'll see later, we can do both!)

::: {.column width="50%"}
::: fragment
```{r, echo = T}
#| code-line-numbers: "|4"
# sort by age
bfi %>% 
  select(gender:age) %>%
  arrange(age) %>% 
  print(n = 6)
```
:::
:::

::: {.column width="50%"}
::: fragment
```{r, echo=TRUE}
#| code-line-numbers: "|4"
# sort by education
bfi %>%
  select(gender:age) %>%
  arrange(education) %>%
  print(n = 6)
```
:::
:::
:::

## 4. `arrange()`

We can also arrange by multiple columns, like if we wanted to sort by gender then education:

::: fragment
```{r, echo = T}
bfi %>%
  select(gender:age) %>%
  arrange(gender, education) %>% 
  print(n = 6)
```
:::

# Bringing it all together: Split-Apply-Combine

## Bringing it all together: Split-Apply-Combine

-   Much of the power of `dplyr` functions lay in the split-apply-combine method

-   A given set of of data are:

    -   *split* into smaller chunks
    -   then a function or series of functions are *applied* to each chunk
    -   and then the chunks are *combined* back together

## 5. `group_by()`

-   The `group_by()` function is the "split" of the method
-   It basically implicitly breaks the data set into chunks by whatever bare quoted column(s)/variable(s) are supplied as arguments.

## 5. `group_by()`

So imagine that we wanted to `group_by()` education levels to get average ages at each level

::: fragment
```{r, echo = T}
bfi %>%
  select(starts_with("C"), age, gender, education) %>%
  group_by(education) %>%
  print(n = 6)
```
:::

## 5. `group_by()`

-   Hadley's first law of data cleaning: "What is split, must be combined"
-   This is super easy with the `ungroup()` function:

::: fragment
```{r, echo=TRUE}
bfi %>%
  select(starts_with("C"), age, gender, education) %>%
  group_by(education) %>%
  ungroup() %>%
  print(n = 6)
```
:::

## 5. `group_by()`

Multiple `group_by()` calls overwrites previous calls:

::: fragment
```{r, echo = T}
bfi %>%
  select(starts_with("C"), age, gender, education) %>%
  group_by(education) %>%
  group_by(gender, age) %>%
  print(n = 6)
```
:::

## 6. `mutate()`

-   `mutate()` is one of your "apply" functions
-   When you use `mutate()`, the resulting data frame will have the same number of rows you started with
-   You are directly mutating the existing data frame, either modifying existing columns or creating new ones

## 6. `mutate()`

To demonstrate, let's add a column that indicated average age levels within each age group

::: fragment
```{r, echo = T}
bfi %>%
  select(starts_with("C"), age, gender, education) %>%
  arrange(education) %>%
  group_by(education) %>% 
  mutate(age_by_edu = mean(age, na.rm = T)) %>%
  print(n = 6)
```
:::

## 6. `mutate()`

`mutate()` is also super useful even when you aren't grouping

::: fragment
We can create a new category

```{r, echo = T}
bfi %>%
  select(starts_with("C"), age, gender, education) %>%
  mutate(gender_cat = plyr::mapvalues(gender, c(1,2), c("Male", "Female")))
```
:::

## 6. `mutate()`

`mutate()` is also super useful even when you aren't grouping

We could also just overwrite it:

::: fragment
```{r, echo = T}
bfi %>%
  select(starts_with("C"), age, gender, education) %>%
  mutate(gender = plyr::mapvalues(gender, c(1,2), c("Male", "Female")))
```
:::

## 7. `summarize()` / `summarise()`

::: columns
::: column
-   `summarize()` is one of your "apply" functions
-   The resulting data frame will have the same number of rows as your grouping variable
-   You number of groups is 1 for ungrouped data frames
:::

::: column
::: fragment
```{r, echo = T}
# group_by() education
bfi %>%
  select(starts_with("C"), age, gender, education) %>%
  arrange(education) %>%
  group_by(education) %>% 
  summarize(age_by_edu = mean(age, na.rm = T))  
```
:::
:::
:::

## 7. `summarize()` / `summarise()`

::: columns
::: column
::: nonincremental
-   `summarize()` is one of your "apply" functions
-   The resulting data frame will have the same number of rows as your grouping variable
-   You number of groups is 1 for ungrouped data frames
:::
:::

::: column
::: fragment
```{r, echo = T}
# no groups  
bfi %>% 
  select(starts_with("C"), age, gender, education) %>%
  arrange(education) %>%
  summarize(age_by_edu = mean(age, na.rm = T))  
```
:::
:::
:::