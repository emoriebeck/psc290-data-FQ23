{"title":"Week 7 Workbook","markdown":{"yaml":{"title":"Week 7 Workbook","author":"Emorie D Beck","format":{"html":{"code-tools":true,"code-copy":true,"code-line-numbers":true,"code-link":true,"theme":"united","highlight-style":"tango","df-print":"paged","code-fold":"show","toc":true,"toc-float":true,"self-contained":true}},"editor":"visual","editor_options":{"chunk_output_type":"console"}},"headingText":"Week 7 - Strings & Dates","containsRefs":false,"markdown":"\n\n```{r, echo = F}\npkg <- c(\"knitr\", \"psych\", \"lme4\", \"broom\", \"broom.mixed\", \"kableExtra\", \"lubridate\", \"plyr\", \"tidyverse\")\npkg <- pkg[!pkg %in% rownames(installed.packages())]\nif(length(pkg) > 0) map(pkg, install.packages)\n\nlibrary(knitr)\nlibrary(psych)\nlibrary(lme4)\nlibrary(broom)\nlibrary(broom.mixed)\nlibrary(kableExtra)\nlibrary(lubridate)\nlibrary(plyr)\nlibrary(tidyverse)\n```\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, \n                      message = FALSE,\t\n                      warning = FALSE,\n                      results = 'show',\n                      fig.width = 4, \n                      fig.height = 4, \n                      fig.retina = 3)\noptions(htmltools.dir.version = FALSE\n        , knitr.kable.NA = \"\")\n```\n\n\n# Outline\n\n1.  Questions on Homework\n2.  Strings\n3.  Regex\n4.  Dates\n\n## Dataset we will use\n\nWe will use `rtweet` to pull Twitter data from the PAC-12 universities. We will use the university admissions Twitter handle if there is one, or the main Twitter handle for the university if there isn't one:\n\n```{r, echo = F}\n# library(rtweet)\n# \n# p12 <- c(\"uaadmissions\", \"FutureSunDevils\", \"caladmissions\", \"UCLAAdmission\",\n#          \"futurebuffs\", \"uoregon\", \"BeaverVIP\", \"USCAdmission\",\n#          \"engagestanford\", \"UtahAdmissions\", \"UW\", \"WSUPullman\")\n# p12_full_df <- search_tweets(paste0(\"from:\", p12, collapse = \" OR \"), n = 500)\n# \n# saveRDS(p12_full_df, \"p12_dataset.RDS\")\n```\n\n```{r}\n# Load previously pulled Twitter data\np12_full_df <- readRDS(\"week7-data.RDS\")\nglimpse(p12_full_df)\n\np12_df <- p12_full_df |> \n  select(user_id, created_at, screen_name, text, location)\nhead(p12_df)\n```\n\n# String basics\n\nWhat are **strings**?\n\n-   String is a type of data in R\n-   You can create strings using either single quotes (`'`) or double quotes (`\"`)\n    -   Internally, R stores strings using double quotes\n-   The `class()` and `typeof()` a string is `character`\n\n## Creating Strings\n\n**Creating string using single quotes**\n\nNotice how R stores strings using double quotes internally:\n\n```{r}\nmy_string <- 'This is a string'\nmy_string\n```\n\n**Creating string using double quotes**\n\n```{r}\nmy_string <- \"Strings can also contain numbers: 123\"\nmy_string\n```\n\n**Checking class and type of strings**\n\n```{r}\nclass(my_string)\ntypeof(my_string)\n```\n\n**Quotes in quotes**\n\n**Note**: To include quotes as part of the string, we can either use the other type of quotes to surround the string (i.e., `'` or `\"`) or escape the quote using a backslash (`\\`).\n\n```{r}\n# Include quote by using the other type of quotes to surround the string \nmy_string <- \"There's no issues with this string.\"\nmy_string\n```\n\n```{r}\n# Include quote of the same type by escaping it with a backslash\nmy_string <- 'There\\'s no issues with this string.'\nmy_string\n```\n\n```{r, eval=F}\n# This would not work\nmy_string <- 'There's an issue with this string.'\nmy_string\n```\n\n# `stringr` package\n\n> \"A consistent, simple and easy to use set of wrappers around the fantastic `stringi` package. All function and argument names (and positions) are consistent, all functions deal with `NA`'s and zero length vectors in the same way, and the output from one function is easy to feed into the input of another.\"\n\n*Credit: `stringr`[R documentation](https://www.rdocumentation.org/packages/stringr/versions/1.4.0)*\n\n-   The `stringr` package is based off the `stringi` package and is part of **Tidyverse**\n-   `stringr` contains functions to work with strings\n-   For many functions in the `stringr` package, there are equivalent \"base R\" functions\n-   But `stringr` functions all follow the same rules, while rules often differ across different \"base R\" string functions, so we will focus exclusively on `stringr` functions\n-   Most `stringr` functions start with `str_` (e.g., `str_length`)\n\n## `str_length()`\n\n**The `str_length()` function**: - Function: Find string length\n\n```{r, eval = FALSE}\n?str_length\n```\n\n```{r, eval = FALSE}\n# SYNTAX\nstr_length(string)\n```\n\n-   Arguments:\n    -   `string`: Character vector (or vector coercible to character)\n-   Note that `str_length()` calculates the length of a string, whereas the `length()` function (which is not part of `stringr` package) calculates the number of elements in an object\n\n**Using `str_length()` on string**\n\n```{r}\nstr_length(\"cats\")\n```\n\nCompare to `length()`, which treats the string as a single object:\n\n```{r}\nlength(\"cats\")\n```\n\n**`str_length()` on character vector**\n\n```{r}\nstr_length(c(\"cats\", \"in\", \"hat\"))\n```\n\nCompare to `length()`, which finds the number of elements in the vector:\n\n```{r}\nlength(c(\"cats\", \"in\", \"hat\"))\n```\n\n**Using `str_length()` on other vectors coercible to character**\n\n-   `Logical` vectors can be coerced to character vectors:\n\n```{r}\nstr_length(c(TRUE, FALSE))\n```\n\n-   `Numeric` vectors can be coerced to character vectors:\n\n```{r}\nstr_length(c(1, 2.5, 3000))\n```\n\n-   `Integer` vectors can be coerced to character vectors:\n\n```{r}\nstr_length(c(2L, 100L))\n```\n\n**Using `str_length()` on dataframe column**\n\nRecall that the columns in a dataframe are just vectors, so we can use `str_length()` as long as the vector is coercible to character type.\n\n```{r}\nstr_length(p12_df$screen_name[1:20])\n```\n\n```{r}\np12_df %>% select(screen_name) %>% unique() %>% \n  mutate(screen_name_len = str_length(screen_name))\n```\n\n## `str_c()`\n\n**The `str_c()` function**:\n\n-   Function: Concatenate strings between vectors (element-wise)\n\n```{r, eval = FALSE}\n?str_c\n\n# SYNTAX AND DEFAULT VALUES\nstr_c(..., sep = \"\", collapse = NULL)\n```\n\n-   Arguments:\n    -   The input is one or more character vectors (or vectors coercible to character)\n        -   Zero length arguments are removed\n        -   Short arguments are recycled to the length of the longest\n    -   `sep`: String to insert between input vectors\n    -   `collapse`: Optional string used to combine input vectors into single string\n\n**Using `str_c()` on one vector**\n\nSince we only provided one input vector, it has nothing to concatenate with, so `str_c()` will just return the same vector:\n\n```{r}\nstr_c(c(\"a\", \"b\", \"c\"))\n```\n\n**Using `str_c()` on one vector**\n\nNote that specifying the `sep` argument will also not have any effect because we only have one input vector, and `sep` is the separator between multiple vectors:\n\n```{r}\nstr_c(c(\"a\", \"b\", \"c\"), sep = \"~\")\n\n# Check length: Output is the original vector of 3 elements\nstr_c(c(\"a\", \"b\", \"c\")) %>% length()\n```\n\n**Using `str_c()` on one vector**\n\n-   As seen on the previous slide, `str_c()` returns a vector by default (because the default value for the `collapse` argument is `NULL`).\n-   But we can specify a string for `collapse` in order to collapse the elements of the output vector into a single string:\n\n```{r}\nstr_c(c(\"a\", \"b\", \"c\"), collapse = \"|\")\n\n# Check length: Output vector of length 3 is collapsed into a single string\nstr_c(c(\"a\", \"b\", \"c\"), collapse = \"|\") %>% length()\n\n# Check str_length: This gives the length of the collapsed string, which is 5 characters long\nstr_c(c(\"a\", \"b\", \"c\"), collapse = \"|\") %>% str_length()\n```\n\n**Using `str_c()` on more than one vector**\n\nWhen we provide multiple input vectors, we can see that the vectors get concatenated element-wise (i.e., 1st element from each vector are concatenated, 2nd element from each vector are concatenated, etc):\n\n```{r}\nstr_c(c(\"a\", \"b\", \"c\"), c(\"x\", \"y\", \"z\"), c(\"!\", \"?\", \";\"))\n```\n\n**Using `str_c()` on more than one vector**\n\nThe default separator for each element-wise concatenation is an empty string (`\"\"`), but we can customize that by specifying the `sep` argument:\n\n```{r}\nstr_c(c(\"a\", \"b\", \"c\"), c(\"x\", \"y\", \"z\"), c(\"!\", \"?\", \";\"), sep = \"~\")\n\n# Check length: Output vector is same length as input vectors\nstr_c(c(\"a\", \"b\", \"c\"), c(\"x\", \"y\", \"z\"), c(\"!\", \"?\", \";\"), sep = \"~\") %>% length()\n```\n\n**Using `str_c()` on more than one vector**\n\nAgain, we can specify the `collapse` argument in order to collapse the elements of the output vector into a single string:\n\n```{r}\nstr_c(c(\"a\", \"b\", \"c\"), c(\"x\", \"y\", \"z\"), c(\"!\", \"?\", \";\"), collapse = \"|\")\n\n# Check length: Output vector of length 3 is collapsed into a single string\nstr_c(c(\"a\", \"b\", \"c\"), c(\"x\", \"y\", \"z\"), c(\"!\", \"?\", \";\"), collapse = \"|\") %>% length()\n\n# Specifying both `sep` and `collapse`\nstr_c(c(\"a\", \"b\", \"c\"), c(\"x\", \"y\", \"z\"), c(\"!\", \"?\", \";\"), sep = \"~\", collapse = \"|\")\n```\n\n## `str_sub()` {.smaller}\n\n**The `str_sub()` function**:\n\n-   Function: Subset strings\n-   Arguments:\n    -   `string`: Character vector (or vector coercible to character)\n    -   `start`: Position of first character to be included in substring (default: `1`)\n    -   `end`: Position of last character to be included in substring (default: `-1`)\n        -   Negative index = counting backwards\n    -   `omit_na`: If `TRUE`, missing values in any of the arguments provided will result in an unchanged input\n\n```{r, eval = FALSE}\n?str_sub\n\n# SYNTAX AND DEFAULT VALUES\nstr_sub(string, start = 1L, end = -1L)\nstr_sub(string, start = 1L, end = -1L, omit_na = FALSE) <- value\n```\n\n-   When `str_sub()` is used in the assignment form, you can replace the subsetted part of the string with a `value` of your choice\n    -   If an element in the vector is too short to meet the subset specification, the replacement `value` will be concatenated to the end of that element\n    -   Note that this modifies your input vector directly, so you must have the vector saved to a variable (see example below)\n\n**Using `str_sub()` to subset strings**\n\nIf no `start` and `end` positions are specified, `str_sub()` will by default return the entire (original) string:\n\n```{r}\nstr_sub(string = c(\"abcdefg\", 123, TRUE))\n```\n\nNote that if an element is shorter than the specified `end` (i.e., `123` in the example below), it will just include all the available characters that it does have:\n\n```{r}\nstr_sub(string = c(\"abcdefg\", 123, TRUE), start = 2, end = 4)\n```\n\nRemember we can also use negative index to count the position starting from the back:\n\n```{r}\nstr_sub(c(\"abcdefg\", 123, TRUE), start = 2, end = -2)\n```\n\n**Using `str_sub()` to replace strings**\n\nIf no `start` and `end` positions are specified, `str_sub()` will by default return the original string, so the entire string would be replaced:\n\n```{r}\nv <- c(\"A\", \"AB\", \"ABC\", \"ABCD\", \"ABCDE\")\nstr_sub(v, start = 1,end =-1)\n\nstr_sub(v, start = 1,end =-1) <- \"*\"\nv\n```\n\n**Using `str_sub()` on dataframe column**\n\nWe can use `as.character()` to turn the `created_at` value to a string, then use `str_sub()` to extract out various date/time components from the string:\n\n```{r}\np12_datetime_df <- p12_df %>% select(created_at) %>%\n  mutate(\n      dt_chr = as.character(created_at),\n      date_chr = str_sub(dt_chr, 1, 10),\n      yr_chr = str_sub(dt_chr, 1, 4),\n      mth_chr = str_sub(dt_chr, 6, 7),\n      day_chr = str_sub(dt_chr, 9, 10),\n      hr_chr = str_sub(dt_chr, -8, -7),\n      min_chr = str_sub(dt_chr, -5, -4),\n      sec_chr = str_sub(dt_chr, -2, -1)\n    )\n\np12_datetime_df\n```\n\n## Other `stringr` functions\n\nOther useful `stringr` functions:\n\n-   `str_to_upper()`: Turn strings to uppercase\n-   `str_to_lower()`: Turn strings to lowercase\n-   `str_sort()`: Sort a character vector\n-   `str_trim()`: Trim whitespace from strings (including `\\n`, `\\t`, etc.)\n-   `str_pad()`: Pad strings with specified character\n\n### Using `str_to_upper()` to turn strings to uppercase\n\nTurn column names of `p12_df` to uppercase:\n\n```{r}\n# Column names are originally lowercase\nnames(p12_df)\n\n# Turn column names to uppercase\nnames(p12_df) <- str_to_upper(names(p12_df))\nnames(p12_df)\n```\n\n### Using `str_to_lower()` to turn strings to lowercase\n\nTurn column names of `p12_df` to lowercase:\n\n```{r}\n# Column names are originally uppercase\nnames(p12_df)\n\n# Turn column names to lowercase\nnames(p12_df) <- str_to_lower(names(p12_df))\nnames(p12_df)\n```\n\n### Using `str_sort()` to sort character vector\n\nSort the vector of `p12_df` column names:\n\n```{r}\n# Before sort\nnames(p12_df)\n\n# Sort alphabetically (default)\nstr_sort(names(p12_df))\n\n# Sort reverse alphabetically\nstr_sort(names(p12_df), decreasing = TRUE)\n```\n\n### Using `str_trim()` to trim whitespace from string\n\n```{r}\n# Trim whitespace from both left and right sides (default)\nstr_trim(c(\"\\nABC \", \" XYZ\\t\"))\n\n# Trim whitespace from left side\nstr_trim(c(\"\\nABC \", \" XYZ\\t\"), side = \"left\")\n\n# Trim whitespace from right side\nstr_trim(c(\"\\nABC \", \" XYZ\\t\"), side = \"right\")\n```\n\n### Using `str_pad()` to pad string with character\n\nLet's say we have a vector of zip codes that has lost all leading 0's. We can use `str_pad()` to add that back in:\n\n```{r}\n# Pad the left side of strings with \"0\" until width of 5 is reached\nstr_pad(c(95035, 90024, 5009, 5030), width = 5, side = \"left\", pad = \"0\")\n```\n\n# Regular expression basics\n\n## Example of using **regular expression** in action:\n\n-   How can we **match all occurrences of times** in the following string? (i.e., `10 AM` and `1 PM`)\n    -   `\"Class starts at 10 AM and ends at 1 PM.\"`\n-   The **regular expression** `\\d+ [AP]M` can!\n\n```{r}\nmy_string = \"Class starts at 10 AM and ends at 1 PM.\"\nmy_regex = \"\\\\d+ [AP]M\"\n\n# The escaped string \"\\\\d\" results in the regex \\d\nprint(my_regex)\nwriteLines(my_regex)\n\n# View matches for our regular expression\nstr_view_all(string = my_string, pattern = my_regex)\n```\n\n-   How the regular expression `\\d+ [AP]M` works:\n    -   `\\d+` matches 1 or more digits in a row\n        -   `\\d` means match all numeric digits (i.e., `0`-`9`)\n        -   `+` means match 1 or more of\n    -   matches a literal space\n    -   `[AP]M` matches either `AM` or `PM`\n        -   `[AP]` means match either an `A` or `P` at that position\n        -   `M` means match a literal `M`\n\n## Some common regular expression patterns include (not inclusive):\n\n-   Character classes\n-   Quantifiers\n-   Anchors\\\n-   Sets and ranges\n-   Groups and backreferences\n\n*Credit: [DaveChild](https://cheatography.com/davechild/cheat-sheets/regular-expressions/) Regular Expression Cheat Sheet*\n\n### Character classes {.smaller}\n\n| STRING  | REGEX | MATCHES                |\n|---------|-------|------------------------|\n| `\"\\\\d\"` | `\\d`  | any digit              |\n| `\"\\\\D\"` | `\\D`  | any non-digit          |\n| `\"\\\\s\"` | `\\s`  | any whitespace         |\n| `\"\\\\S\"` | `\\S`  | any non-whitespace     |\n| `\"\\\\w\"` | `\\w`  | any word character     |\n| `\"\\\\W\"` | `\\W`  | any non-word character |\n\n*Credit: [Working with strings in stringr](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) Cheat sheet*\n\n-   There are certain **character classes** in regular expression that have special meaning. For example:\n\n    -   `\\d` is used to match any digit (i.e., *number*)\n    -   `\\s` is used to match any whitespace (i.e., *space, tab, or newline character*)\n    -   `\\w` is used to match any word character (i.e., *alphanumeric character or underscore*)\n\n-   \"But wait... there's more! Before a regex is interpreted as a regular expression, it is also interpreted by R as a string. And backslash is used to escape there as well. So, in the end, you need to preprend two backslashes...\"\n\n-   *Credit: [Escaping sequences](https://stat545.com/character-vectors.html#escaping) from Stat 545*\n\n-   This means in R, when we want to use regular expression patterns `\"\\d\"`,`\"\\s\"`, `\"\\w\"`, etc. to match to strings, we must write out the regex patterns as `\"\\\\d\"`,`\"\\\\s\"`, `\"\\\\w\"`, etc.\n\n### Using `\\d` & `\\D` to match digits & non-digits\n\n-   Goal: write a regular expression pattern that matches to any digit in the string `p12_df$text[119]`\n-   We can use `\\d` to match all instances of a digit (i.e., *number*):\n\n```{r}\n# Match any instances of a digit\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\d\")\n```\n\n### KEY POINT WITH REGEX\n\n-   Our regular expression is the value we specify for the `pattern` argument above; this is our \"regex object\"\n-   We want our regex object to include the regular expression `\\d`, which matches to any digit\n-   We specify our regex object as `\"\\\\d\"` rather than `\"\\d\"`\n\n### Use regular expression `\\D` to match all instances of a non-digit character:\n\n```{r}\n# Match any instances of a non-digit\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\D\")\n```\n\n**Match to all instances of a digit followed by a non-digit character:**\n\n```{r}\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\d\\\\D\")\n```\n\n### Using `\\s` & `\\S` to match whitespace & non-whitespace\n\nWe can use `\\s` to match all instances of a whitespace (i.e., *space, tab, or newline character*):\n\n```{r}\n# Match any instances of a whitespace\nstr_view_all(\n  string = p12_df$text[119]\n  , pattern = \"\\\\s\"\n  )\n```\n\nWe can use `\\S` to match all instances of a non-whitespace character:\n\n```{r}\n# Match any instances of a non-whitespace\nstr_view_all(\n  string = p12_df$text[119]\n  , pattern = \"\\\\S\"\n  )\n```\n\n### Using `\\w` & `\\W` to match words & non-words\n\nWe can use `\\w` to match all instances of a word character (i.e., *alphanumeric character or underscore*):\n\n```{r}\n# Match any instances of a word character\nstr_view_all(\n  string = p12_df$text[119]\n  , pattern = \"\\\\w\"\n  )\n```\n\nWe can use `\\W` to match all instances of a non-word character:\n\n```{r}\n# Match any instances of a non-word character\nstr_view_all(\n  string = p12_df$text[119]\n  , pattern = \"\\\\W\"\n  )\n```\n\nThis matches all instances of 3-letter words:\n\n```{r}\nstr_view_all(\n  string = p12_df$text[119]\n  , pattern = \"\\\\W\\\\w\\\\w\\\\w\\\\W\"\n  )\n```\n\n### Wrap-Up: Character Classes {.smaller}\n\n-   The second half of the table above shows other regular expressions involving backslashes\n-   This includes special characters like `\\n` and `\\t`, as well as using backslash to escape characters that have special meanings in regex, like `.` or `?` (as we will soon see.\n-   So to match a literal period or question mark, we need to use the regex `\\.` and `\\?`, or strings `\"\\\\.\"` and `\"\\\\?\"` in R.\n\n| STRING   | REGEX | MATCHES |\n|----------|-------|---------|\n| `\"\\\\n\"`  | `\\n`  | newline |\n| `\"\\\\t\"`  | `\\t`  | tab     |\n| `\"\\\\\\\\\"` | `\\\\`  | `\\`     |\n| `\"\\\\.\"`  | `\\.`  | `.`     |\n| `\"\\\\?\"`  | `\\?`  | `?`     |\n| `\"\\\\(\"`  | `\\(`  | `(`     |\n| `\"\\\\)\"`  | `\\)`  | `)`     |\n| `\"\\\\{\"`  | `\\{`  | `{`     |\n| `\"\\\\}\"`  | `\\}`  | `}`     |\n\n## Quantifiers\n\n| Character | Description |\n|:----------|:------------|\n| `*`       | 0 or more   |\n| `?`       | 0 or 1      |\n| `+`       | 1 or more   |\n| `{3}`     | Exactly 3   |\n| `{3,}`    | 3 or more   |\n| `{3,5}`   | 3, 4, or 5  |\n\n-   We can use **quantifiers** to specify the amount of a certain character or expression to match.\n-   The quantifier should directly follow the pattern you want to quantify.\n-   For example, `s?` matches 0 or 1 `s` and `\\d{4}` matches exactly 4 digits.\n\n### Using the `*`, `?`, and `+` quantifiers\n\nWe can use `*` to match 0 or more of a pattern:\n\n```{r}\n# Matches all instances of `s` followed by 0 or more non-word character\nstr_view_all(string = p12_df$text[119], pattern = \"s\\\\W*\")\n```\n\n### Using the `*`, `?`, and `+` quantifiers\n\nWe can use `?` to match 0 or 1 of a pattern:\n\n```{r}\n# Matches all instances of `s` followed by 0 or 1 non-word character\nstr_view_all(string = p12_df$text[119], pattern = \"s\\\\W?\")\n```\n\n### Using the `*`, `?`, and `+` quantifiers\n\nWe can use `+` to match 1 or more of a pattern:\n\n```{r}\n# Matches all instances of `s` followed by 1 or more non-word character\nstr_view_all(string = p12_df$text[119], pattern = \"s\\\\W+\")\n\n# Matche all twitter hashtags\n  # hashtag defined as hashtag character # followed by 1 or more word characters\nstr_view_all(string = p12_df$text[119], pattern = \"#\\\\w+\")\n```\n\n### Using `{...}` to specify how many occurrences to match\n\nWe can use `{n}` to specify the exact number of characters or expressions to match:\n\n```{r}\n# Matches words with exactly 3 letters\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\s\\\\w{3}\\\\s\")\n```\n\n### Using `{...}` to specify how many occurrences to match\n\nWe can use `{n,}` to specify `n` as the minimum amount to match:\n\n```{r}\n# Matches words with 3 or more letters\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\s\\\\w{3,}\\\\s\")\n```\n\n### Using `{...}` to specify how many occurrences to match\n\nWe can use `{n,m}` to specify we want to match between `n` and `m` amount (inclusive):\n\n```{r}\n# Matches words with between 3 to 5 letters (inclusive)\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\s\\\\w{3,5}\\\\s\")\n```\n\n## Anchors\n\n-   We can use **anchors** to indicate which part of the string to match.\n-   For example, `^` matches the start of the string, `$` matches the end of the string (*Notice how we do not need to escape these characters*).\n-   `\\b` can be used to help detect word boundaries, and `\\B` can be used to help match characters within a word.\n\n| String  | Character | Description                                             |\n|:--------|:----------|:--------------------------------------------------------|\n| `\"^\"`   | `^`       | Start of string, or start of line in multi-line pattern |\n| `\"$\"`   | `$`       | End of string, or end of line in multi-line pattern     |\n| `\"\\\\b\"` | `\\b`      | Word boundary                                           |\n| `\"\\\\B\"` | `\\B`      | Non-word boundary                                       |\n\n### Using `^` & `$` to match start & end of string\n\nWe can use `^` to match the start of a string:\n\n```{r}\n# Matches only the quotation mark at the start of the text and not the end quote\nstr_view_all(string = p12_df$text[119], pattern = '^\"')\n```\n\n### Using `^` & `$` to match start & end of string\n\nWe can use `$` to match the end of a string:\n\n```{r}\n# Matches only the number at the end of the text and not any other numbers\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\d$\")\n```\n\n### Using `\\b` & `\\B` to match word boundary & non-word boundary\n\nWe can use `\\b` to help detect word boundary:\n\n```{r}\n# Match to all word bounraries\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\b\")\n```\n\n```{r}\n# Matches words with 3 or more letters using \\b\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\b\\\\w{3,}\\\\b\")\n```\n\nNotice how this is much flexible than trying to use whitespace (`\\s`) to determine word boundary:\n\n```{r}\n# Matches words with 3 or more letters using \\s\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\s\\\\w{3,}\\\\s\")\n```\n\nRegular expression `\\B` matches to \"non-word boundary\"; what does that mean?\n\n```{r}\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\B\")\n```\n\nWe can use `\\B` to help match characters within a word:\n\n```{r}\n# Matches only the letter `s` within a word and not at the start or end\nstr_view_all(string = p12_df$text[119], pattern = \"\\\\Bs\\\\B\")\n```\n\n## Sets and ranges\n\n| Character | Description                                      |\n|:----------|:-------------------------------------------------|\n| `.`       | Match any character except newline (`\\n`)        |\n| `a|b`     | Match `a` or `b`                                 |\n| `[abc]`   | Match either `a`, `b`, or `c`                    |\n| `[^abc]`  | Match anything except `a`, `b`, or `c`           |\n| `[a-z]`   | Match range of lowercase letters from `a` to `z` |\n| `[A-Z]`   | Match range of uppercase letters from `A` to `Z` |\n| `[0-9]`   | Match range of numbers from `0` to `9`           |\n\n-   The table lists some more ways regular expression offers us flexibility and option in what we want to match.\n-   The period `.` acts as a **wildcard** to match any character except newline.\n-   The vertical bar `|` is similar to an **OR** operator. Square brackets `[...]` can be used to specify a set or range of characters to match (or not to match).\n\n### Using `.` as a wildcard\n\nWe can use `.` to match any character except newline (`\\n`):\n\n```{r}\n# Matches any character except newline\nstr_view_all(string = p12_df$text[119], pattern = \".\")\n```\n\nWe can confirm there is a newline in the tweet above by using `writeLines()` or `print()`:\n\n```{r}\nwriteLines(p12_df$text[119])\n\nprint(p12_df$text[119])\n```\n\n### Using `|` as an OR operator\n\nWe can use `|` to match either one of multiple patterns:\n\n```{r}\n# Matches `research`, `fight`, or `labs`\nstr_view_all(string = p12_df$text[119], pattern = \"research|fight|labs\")\n\n# Matches hashtags or handles\nstr_view_all(string = p12_df$text[119], pattern = \"@\\\\w+|#\\\\w+\")\n```\n\n## #Using `[...]` to match (or not match) a set or range of characters\n\nWe can use `[...]` to match any set of characters:\n\n```{r}\n# Matches hashtags or handles\nstr_view_all(string = p12_df$text[119], pattern = \"[@#]\\\\w+\")\n\n# Matches any 2 consecutive vowels\nstr_view_all(string = p12_df$text[119], pattern = \"[aeiouAEIOU]{2}\")\n```\n\nWe can also use `[...]` to match any range of alpha or numeric characters:\n\n```{r}\n# Matches only lowercase x through z or uppercase A through C\nstr_view_all(string = p12_df$text[119], pattern = \"[x-zA-C]\")\n\n# Matches only numbers 1 through 4 or the pound sign\nstr_view_all(string = p12_df$text[119], pattern = \"[1-4#]\")\n```\n\nWe can use `[^...]` to indicate we do not want to match the provided set or range of characters:\n\n```{r}\n# Matches any vowels\nstr_view_all(string = p12_df$text[119], pattern = \"[aeiouAEIOU]\")\n\n# Matches anything except vowels\nstr_view_all(string = p12_df$text[119], pattern = \"[^aeiouAEIOU]\")\n\n# Matches anything that's not uppercase letters\nstr_view_all(string = p12_df$text[119], pattern = \"[^A-Z]+\")\n```\n\nNotice that `[...]` only matches a single character (see second to last example above). We need to use quantifiers if we want to match a stretch of characters (see last example above).\n\n# Dates and times\n\n> \"Date-time data can be frustrating to work with in R. R commands for date-times are generally unintuitive and change depending on the type of date-time object being used. Moreover, the methods we use with date-times must be robust to time zones, leap days, daylight savings times, and other time related quirks, and R lacks these capabilities in some situations. Lubridate makes it easier to do the things R does with date-times and possible to do the things R does not.\"\n\n*Credit: `lubridate`[documentation](https://lubridate.tidyverse.org/)*\n\nHow are dates and times stored in R? (From [Dates and Times in R](https://www.stat.berkeley.edu/~s133/dates.html))\n\n-   The `Date` class is used for storing dates\n    -   \"Internally, `Date` objects are stored as the number of days since January 1, 1970, using negative numbers for earlier dates. The `as.numeric()` function can be used to convert a `Date` object to its internal form.\"\n-   POSIX classes can be used for storing date plus times\n    -   \"The `POSIXct` class stores date/time values as the number of seconds since January 1, 1970\"\n    -   \"The `POSIXlt` class stores date/time values as a list of components (hour, min, sec, mon, etc.) making it easy to extract these parts\"\n-   There is no native R class for storing only time\n\n**Why use date/time objects?**\n\n-   Using date/time objects makes it easier to fetch or modify various date/time components (e.g., year, month, day, day of the week)\n    -   Compared to if the date/time is just stored in a string, these components are not as readily accessible and need to be parsed\n-   You can perform certain arithmetics with date/time objects (e.g., find the \"difference\" between date/time points)\n\n## Creating date/time objects\n\nFunctions that create date/time objects **by parsing character or numeric input**:\n\n-   Create `Date` object: `ymd()`, `ydm()`, `mdy()`, `myd()`, `dmy()`, `dym()`\n    -   `y` stands for year, `m` stands for month, `d` stands for day\n    -   Select the function that represents the order in which your date input is formatted, and the function will be able to parse your input and create a `Date` object\n\n### Creating POSIXct objects\n\n-   Create `POSIXct` object: `ymd_h()`, `ymd_hm()`, `ymd_hms()`, etc.\n    -   `h` stands for hour, `m` stands for minute, `s` stands for second\n    -   For any of the previous 6 date functions, you can append `h`, `hm`, or `hms` if you want to provide additional time information in order to create a `POSIXct` object\n    -   To force a `POSIXct` object without providing any time information, you can just provide a timezone (using `tz`) to one of the date functions and it will assume midnight as the time\n    -   You can use `Sys.timezone()` to get the timezone for your location\n\n### Creating `Date` object from character or numeric input\n\nThe `lubridate` functions are flexible and can parse dates in various formats:\n\n```{r}\nd <- mdy(\"1/1/2020\"); d\n\nd <- mdy(\"1-1-2020\"); d\n\nd <- mdy(\"Jan. 1, 2020\"); d\n\nd <- ymd(20200101); d\n```\n\n### Creating `Date` object from character or numeric input\n\nInvestigate the `Date` object:\n\n```{r}\nclass(d)\ntypeof(d)\n\n# Number of days since January 1, 1970\nas.numeric(d)\n```\n\n### Creating `POSIXct` object from character or numeric input\n\nThe `lubridate` functions are flexible and can parse AM/PM in various formats:\n\n```{r}\ndt <- mdy_h(\"12/31/2019 11pm\"); dt\n\ndt <- mdy_hm(\"12/31/2019 11:59 pm\"); dt\n\ndt <- mdy_hms(\"12/31/2019 11:59:59 PM\"); dt\n\ndt <- ymd_hms(20191231235959); dt\n```\n\nInvestigate the `POSIXct` object:\n\n```{r}\nclass(dt)\ntypeof(dt)\n\n# Number of seconds since January 1, 1970\nas.numeric(dt)\n```\n\nWe can also create a `POSIXct` object from a date function by providing a timezone. The time would default to midnight:\n\n```{r}\ndt <- mdy(\"1/1/2020\", tz = \"UTC\")\ndt\n\n# Number of seconds since January 1, 1970\nas.numeric(dt)  # Note that this is indeed 1 sec after the previous example\n```\n\n### Creating `Date` objects from dataframe column\n\nUsing the `p12_datetime_df` we created earlier, we can create `Date` objects from the `date_chr` column:\n\n```{r}\n# Use `ymd()` to parse the string stored in the `date_chr` column\np12_datetime_df %>% select(created_at, dt_chr, date_chr) %>%\n  mutate(date_ymd = ymd(date_chr))\n```\n\n### Creating `POSIXct` objects from dataframe column\n\nUsing the `p12_datetime_df` we created earlier, we can recreate the `created_at` column (class `POSIXct`) from the `dt_chr` column (class `character`):\n\n```{r}\n# Use `ymd_hms()` to parse the string stored in the `dt_chr` column\np12_datetime_df %>% select(created_at, dt_chr) %>%\n  mutate(datetime_ymd_hms = ymd_hms(dt_chr))\n```\n\n### Creating date/time objects from individual components\n\nFunctions that create date/time objects **from various date/time components**:\n\n-   Create `Date` object: `make_date()`\n    -   Syntax and default values: `make_date(year = 1970L, month = 1L, day = 1L)`\n    -   All inputs are coerced to integer\n-   Create `POSIXct` object: `make_datetime()`\n    -   Syntax and default values: `make_datetime(year = 1970L, month = 1L, day = 1L, hour = 0L, min = 0L, sec = 0, tz = \"UTC\")`\n\nThere are various ways to pass in the inputs to create the same `Date` object:\n\n```{r}\nd <- make_date(2020, 1, 1); d\n# Characters can be coerced to integers\nd <- make_date(\"2020\", \"01\", \"01\"); d\n# Remember that the default values for month and day would be 1L\nd <- make_date(2020); d\n```\n\n### Creating `POSIXct` object from individual components\n\n```{r}\n# Inputs should be numeric\nd <- make_datetime(2019, 12, 31, 23, 59, 59)\nd\n```\n\n### Creating `Date` objects from dataframe columns\n\nUsing the `p12_datetime_df` we created earlier, we can create `Date` objects from the various date component columns:\n\n```{r}\n# Use `make_date()` to create a `Date` object from the `yr_chr`, `mth_chr`, `day_chr` fields\np12_datetime_df %>% select(created_at, dt_chr, yr_chr, mth_chr, day_chr) %>%\n  mutate(date_make_date = make_date(year = yr_chr, month = mth_chr, day = day_chr))\n```\n\n### Creating `POSIXct` objects from dataframe columns\n\nUsing the `p12_datetime_df` we created earlier, we can recreate the `created_at` column (class `POSIXct`) from the various date and time component columns (class `character`):\n\n```{r}\n# Use `make_datetime()` to create a `POSIXct` object from the `yr_chr`, `mth_chr`, `day_chr`, `hr_chr`, `min_chr`, `sec_chr` fields\n# Convert inputs to integers first\np12_datetime_df %>%\n  mutate(datetime_make_datetime = make_datetime(\n    as.integer(yr_chr), as.integer(mth_chr), as.integer(day_chr), \n    as.integer(hr_chr), as.integer(min_chr), as.integer(sec_chr)\n  )) %>%\n  select(datetime_make_datetime, yr_chr, mth_chr, day_chr, hr_chr, min_chr, sec_chr)\n```\n\n## Date/time object components\n\nStoring data using date/time objects makes it easier to **get and set** the various date/time components.\n\nBasic accessor functions:\n\n-   `date()`: Date component\n\n-   `year()`: Year\n\n-   `month()`: Month\n\n-   `day()`: Day\n\n-   `hour()`: Hour\n\n-   `minute()`: Minute\n\n-   `second()`: Second\n\n-   `week()`: Week of the year\n\n-   `wday()`: Day of the week (`1` for Sunday to `7` for Saturday)\n\n-   `am()`: Is it in the am? (returns `TRUE` or `FALSE`)\n\n-   `pm()`: Is it in the pm? (returns `TRUE` or `FALSE`)\n\n-   To **get** a date/time component, you can simply pass a date/time object to the function\n\n    -   Syntax: `accessor_function(<date/time_object>)`\n\n-   To **set** a date/time component, you can assign into the accessor function to change the component\n\n    -   Syntax: `accessor_function(<date/time_object>) <- \"new_component\"`\n    -   Note that `am()` and `pm()` can't be set. Modify the time components instead.\n\n```{r}\n# Create datetime for New Year's Eve\ndt <- make_datetime(2019, 12, 31, 23, 59, 59)\ndt\ndt %>% class()\n\ndate(dt) # Get date\nhour(dt) # Get hour\npm(dt)   # Is it pm?\nwday(dt) # Day of the week (3 = Tuesday)\nyear(dt) # Get year\n```\n\n## Setting date/time components\n\n```{r}\nweek(dt) # Get week of year\n# Set week of year (move back 1 week)\nweek(dt) <- week(dt) - 1\ndt\nday(dt) <- 25 # Set day to Christmas Day\ndt\n```\n\n## Getting date/time components from dataframe column\n\nUsing the `p12_datetime_df` we created earlier, we can isolate the various date/time components from the `POSIXct` object in the `created_at` column:\n\n```{r}\n# The extracted date/time components will be of numeric type\np12_datetime_df %>% select(created_at) %>%\n  mutate(\n    yr_num = year(created_at),\n    mth_num = month(created_at),\n    day_num = day(created_at),\n    hr_num = hour(created_at),\n    min_num = minute(created_at),\n    sec_num = second(created_at),\n    ampm = ifelse(am(created_at), 'AM', 'PM')  # am()/pm() returns TRUE/FALSE\n  )\n```\n\n## Time spans {.smaller}\n\n3 ways to represent time spans (From [lubridate cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf))\n\n-   **Intervals** represent specific intervals of the timeline, bounded by start and end date-times\n    -   Example: People with birthdays between the **interval** October 23 to November 22 are Scorpios\n-   **Periods** track changes in clock times, which ignore time line irregularities\n    -   Example: Daylight savings time ends at the beginning of November and we gain an hour - this extra hour is *ignored* when determining the **period** between October 23 to November 22\n-   **Durations** track the passage of physical time, which deviates from clock time when irregularities occur\n    -   Example: Daylight savings time ends at the beginning of November and we gain an hour - this extra hour is *added* when determining the **duration** between October 23 to November 22\n\nUsing the `lubridate` package for time spans:\n\n-   **Interval**\n    -   Create an interval using `interval()` or `%--%`\n        -   Syntax: `interval(<date/time_object1>, <date/time_object2>)` or `<date/time_object1> %--% <date/time_object2>`\n\n### Time spans using `lubridate`: Periods\n\n-   \"Periods are time spans but don't have a fixed length in seconds, instead they work with '*human*' times, like days and months.\" (From [R for Data Science](https://r4ds.had.co.nz/dates-and-times.html#periods))\n-   Create periods using functions whose name is the time unit pluralized (e.g., `years()`, `months()`, `weeks()`, `days()`, `hours()`, `minutes()`, `seconds()`)\n-   You can add and subtract periods\n-   You can also use `as.period()` to get period of an interval\n\n```{r}\ndays(1)\n```\n\n### Time spans using `lubridate`: Durations\n\n-   Durations keep track of the physical amount of time elapsed, so it is \"stored as seconds, the only time unit with a consistent length\" (From [lubridate cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf))\n\n-   Create durations using functions whose name is the time unit prefixed with a `d` (e.g., `dyears()`, `dweeks()`, `ddays()`, `dhours()`, `dminutes()`, `dseconds()`)\n\n-   Example: `ddays(1)` creates a duration of `86400s`, using the standard conversion of `60` seconds in an minute, `60` minutes in an hour, and `24` hours in a day:\n\n```{r}\nddays(1)\n```\n\nNotice that the output says this is equivalent to *approximately* `1` day, since it acknowledges that not all days have `24` hours.\n\nIn the case of daylight savings, one particular day may have `25` hours, so the duration of that day should be represented as:\n\n```{r}\nddays(1) + dhours(1)\n```\n\n-   You can add and subract durations\n-   You can also use `as.duration()` to get duration of an interval\n\n## Working with interval {.smaller}\n\n```{r}\n# Use `Sys.timezone()` to get timezone for your location (time is midnight by default)\nscorpio_start <- ymd(\"2019-10-23\", tz = Sys.timezone())\nscorpio_end <- ymd(\"2019-11-22\", tz = Sys.timezone())\n\nscorpio_start\n# These datetime objects have class `POSIXct`\nclass(scorpio_start)\n\n# Create interval for the datetimes\nscorpio_interval <- scorpio_start %--% scorpio_end  # or `interval(scorpio_start, scorpio_end)`\nscorpio_interval <- interval(scorpio_start, scorpio_end)\nscorpio_interval\n\n# The object has class `Interval`\nclass(scorpio_interval)\nas.numeric(scorpio_interval)\n```\n\n## Working with period\n\nIf we use `as.period()` to get the period of `scorpio_interval`, we see that it is a period of `30` days. We do not worry about the extra `1` hour gained due to daylight savings ending:\n\n```{r}\n# Period is 30 days\nscorpio_period <- as.period(scorpio_interval)\nscorpio_period\n\n# The object has class `Period`\nclass(scorpio_period)\n```\n\nBecause periods work with \"human\" times like days, it is more intuitive. For example, if we add a period of `30` days to the `scorpio_start` datetime object, we get the expected end datetime that is `30` days later:\n\n```{r}\n# Start datetime for Scorpio birthdays (time is midnight)\nscorpio_start\n\n# After adding 30 day period, we get the expected end datetime (time is midnight)\nscorpio_start + days(30)\n```\n\n## Working with duration\n\nIf we use `as.duration()` to get the duration of `scorpio_interval`, we see that it is a duration of `2595600` seconds. It takes into account the extra `1` hour gained due to daylight savings ending:\n\n```{r}\n# Duration is 2595600 seconds, which is equivalent to 30 24-hr days + 1 additional hour\nscorpio_duration <- as.duration(scorpio_interval)\nscorpio_duration\n\n# The object has class `Duration`\nclass(scorpio_duration)\n\n# Using the standard 60s/min, 60min/hr, 24hr/day conversion,\n# confirm duration is slightly more than 30 \"standard\" (ie. 24-hr) days\n2595600 / (60 * 60 * 24)\n\n# Specifically, it is 30 days + 1 hour, if we define a day to have 24 hours\nseconds_to_period(scorpio_duration)\n```\n\nBecause durations work with physical time, when we add a duration of `30` days to the `scorpio_start` datetime object, we do not get the end datetime we'd expect:\n\n```{r}\n# Start datetime for Scorpio birthdays (time is midnight)\nscorpio_start\n\n# After adding 30 day duration, we do not get the expected end datetime\n# `ddays(30)` adds the number of seconds in 30 standard 24-hr days, but one of the days has 25 hours\nscorpio_start + ddays(30)\n\n# We need to add the additional 1 hour of physical time that elapsed during this time span\nscorpio_start + ddays(30) + dhours(1)\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":true,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"highlight-style":"tango","self-contained":true,"output-file":"07-week7-workbook.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"visual","theme":"cosmo","title":"Week 7 Workbook","author":"Emorie D Beck","editor_options":{"chunk_output_type":"console"},"code-copy":true,"toc-float":true},"extensions":{"book":{"multiFile":true}}}}}